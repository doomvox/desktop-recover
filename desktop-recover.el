;;; desktop-recover.el ---

;; Copyright 2009 Joseph Brenner
;;
;; Author: doom@kzsu.stanford.edu
;; Version: $Id: desktop-recover.el,v 0.0 2009/07/08 02:59:21 doom Exp $
;; Keywords:
;; X-URL: not distributed yet

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program; if not, write to the Free Software
;; Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

;;; Commentary:

;;  Works with the .emacs-desktop files (as generated by desktop.el),
;;  but unlike with desktop-read, provides an interactive menu that
;;  let's the user choose which buffers will be restored.

;; Put this file into your load-path and the following into your ~/.emacs:
;;  (require 'desktop-recover)
;;  ;; optionallly:
;;  (setq desktop-recover-location
;;     (desktop-recover-fixdir "$HOME/.emacs.d/")) ;; ~/.emacs.d is the default
;;  Something like this is highly recommended:
;;  (prefer-coding-system 'utf-8)
;;  ;; Brings up the interactive buffer restore menu
;;  (desktop-recover-interactive)
;;  ;; Note that after using this menu, your desktop will be saved
;;  ;; automatically (triggered by the auto-save mechanism).

;;  For finer-grained control of the frequency of desktop saves,
;;  you can add the standard keybindings to your set-up:
;;   (desktop-recover-define-global-key-bindings "\C-c%")

;;; Code:

(provide 'desktop-recover)
(eval-when-compile
  (require 'cl))

(require 'desktop)
(require 'thingatpt)

(defconst desktop-recover-version "0.93"
  "The version number of the installed desktop-recover.el package.")



;;======
;; poor man's pod/lazy man's info:
;;   dummy variables with documentation attached

(defvar desktop-recover-doc-toc ""
  "The table-of-contents for the documentation.
Several variables \(including this one\) are defined just
to have a convenient place to attach documentation strings:\n
Introduction:          `desktop-recover-doc-desktop'
Basic How-To:          `desktop-recover-doc-howto'
Philosophy:            `desktop-recover-doc-philosophy'
How-to run many emacs  `desktop-recover-doc-howto-multiple-emacsen'
Key bindings:          `desktop-recover-doc-keybindings'
\n
Internal documentation:
  `desktop-recover-doc-dangling-buffers'
  `desktop-recover-doc-desktop-list'
")

(defvar desktop-recover-doc-desktop ""
  "We use the term \"desktop\" to mean the emacs desktop,
i.e. the state of all the current buffers that are open at a
given moment \(except for the dynamic buffers-- usually with
names \"*surrounded by asterix*\"-- and a few other odds and
ends\).  This is the terminology used by the package
\"desktop.el\" \(already standard with GNU emacs\).  This
package, \"desktop-recover.el\", works with \"desktop.el\", using
it for interactive recovery of emacs state \(e.g. for crash
recovery for people working over flaky network connections\).\n
For other notes, see `desktop-recover-doc-toc'.")
;; it's also likely that this can be used with things like
;; project-root to implement project-specific desktops.

(defvar desktop-recover-doc-howto ""
  "Setup:
   (1) Put the desktop-recover.el file somewhere in your load-path\n
   (2) Add the following lines to your ~/.emacs:
     (require 'desktop-recover)
     ;; Highly recommended to keep emacs from bugging you about coding systems:
     (prefer-coding-system 'utf-8)
     ;; Optional settings:
     ;;   if you'd like to specify where the desktop should be saved:
       (setq desktop-recover-location
          (desktop-recover-fixdir \"$HOME/.emacs.d/\"))
     ;;   increase this to save the desktop less often (e.g. if disk is slow):
       (setq desktop-recover-save-period 3)
     ;; brings up the interactive buffer restore menu
     (desktop-recover-interactive)\n
Now when you invoke emacs, you should see a listing of the
buffers that were left open when you last exited emacs \(even if
you didn't get a chance to exit cleanly\).  If you can just hit
\"Enter\" you can restore all of the indicated buffers (the ones
marked with an \"*\"), or first you adjust the selections by
cursoring up and down and using \"u\" to unmark and \"*\" to
mark.\n
That's about all you need to know to get started.  There are some
other details that you may like to know eventually: the presence of
a newer auto-save file is indicated with a \"%\" \(next to the \"*\"\).
These auto-saves are recovered automatically, but you tell it to skip
one by doing a \"%\" on that line.  If you had any temporary buffers
that weren't saved to files, this system will automatically preserve
them in a special temp directory: they're restored by default if
you did not exit cleanly, but if you did they will not be selected
by default.\n
If you like, you can ignore the \"*Desktop Recover Menu\" for awhile,
and do the recovery step later, but you should realize that your
desktop will not be automatically saved again until after you've
hit Enter in that menu.\n
For other notes, see `desktop-recover-doc-toc'.")

(defvar desktop-recover-doc-philosophy ""
  "In many respects desktop-recover.el works more simply than desktop.el.
While desktop-recover.el uses desktop.el internally to save the
state of the emacs \"desktop\", it intentionally overrides some
features: (1) By itself, desktop.el is very cautious about
keeping desktop files locked, so that it can warn the user if it
looks like two different emacs instances are trying to use the
same file.  (2) desktop.el also dynamically searches several
likely locations to find a desktop file, making it's behavior a
little unpredictable.  This package, desktop-recover.el takes a
somewhat different approach: the presumption is that there is
nothing critical about saving desktop state; it's just a
convenience feature, and so there's no good reason to bother the
user about confirmations in the event of an apparent conflict
\(and note that for our purposes, the desktop file is always
going to be read by a different emacs process than the one that
wrote it\).  The basic desktop-recover save primitive is
\\[desktop-recover-force-save], which just ignores any desktop.el
locks.  If you're worried about concurrently running emacs
processes fighting over the same desktop file, then you shouldn't
start two of them that use the same location.  That's easier to
do with desktop-recover.el, because it has a single variable that
can be set to tell it where to save: `desktop-recover-location'.
To get desktop.el's dynamically determined `desktop-dirname'
behavior, `desktop-recover-location' can be set to nil, but when
it is set, desktop-recover.el will really use that location,
overriding desktop.el's dynamic search.
`desktop-recover-location' defaults to the value of
`user-emacs-directory', which is typically \"~/.emacs.d\".\n
In order to supress saves, desktop.el code internally sets the
`desktop-dirname' to nil, in contrast, desktop-recover.el has the
function \\[desktop-recover-stop-automatic-saves] and also the
variable `desktop-recover-suppress-save' \(an older, but still
effective mechanism\).\n
For other notes, see `desktop-recover-doc-toc'.")

(defvar desktop-recover-doc-howto-multiple-emacsen ""
 "If you feel the need to regularly run multiple emacs processes
in parallel \(for example, I'm inclined to use one for MH-E,
one for gnus, and a third for development work\) it's recommended
to either only run desktop-recover.el in one emacs at a time,
or alternately to make sure that each process is using a
different `desktop-recover-location' location.  Note that unlike
desktop.el, desktop-recover.el does not use lock files to prevent
over-writing someone else's desktop file (See `desktop-recover-doc-philosophy').
There are a number of techniques you might use when running
multiple instances of emacs with desktop-recover.el enabled:

 o  Manually avoid desktop saves from secondary emacsen:
    Simply don't hit enter in the recover menu, and the
    desktop will never be auto saved for that emacs.
    You can kill the recover menu buffer without hurting
    anything.

 o  Initialize each emacs with a different `desktop-recover-location'
    \(Myself, I do this with a wrapper script that launches
    emacs\).

 o  Set the `desktop-recover-suppress-save' variable for the
    secondary emacsen.

 o  \(Not yet implemented\) The \"--no-desktop\" start-up flag
    documented for desktop.el is also respected by
    desktop-recover.el  TODO
For other notes, see `desktop-recover-doc-toc'.")

(defvar desktop-recover-doc-keybindings ""
  "No keybindings are expected to be required for normal operation,
but there are some that might be useful in certain cases, which
you can get most easily by adding this to your set-up:

    \(desktop-recover-define-global-key-bindings \"\\C-c%\"\)

The argument shown is the key stroke prefix, where the indicated
\"control c percent\" is the default prefix.  With this setup,
you would then have these keybindings:

  C-c % +    desktop-recover-increase-save-period
  C-c % -    desktop-recover-decrease-save-period
  C-c % s    desktop-recover-save-with-danglers

Normally, the desktop is saved every 3 \"auto save\" cycles
\(i.e. with a period of 3\), but if your disk is relatively slow,
you might prefer to save it less frequently.  The first two
commands make it easy to experiment with different save
frequencies, increasing the period with: C-c % -
and decreasing it with: C-c % - \n
If you feel the need to manually save the desktop at some
point, you can use: C-c % s \n
For other notes, see `desktop-recover-doc-toc'.")

(defvar desktop-recover-doc-dangling-buffers ""
  "We use \"dangling buffers\" to mean buffers without associated files.
Typically that excludes the special display buffers (which
usually begin with an asterix) along with dired or shell buffers.
We're concerned here with buffers used for temporary notes that
might've been prematurely lost by an emacs crash \(e.g. due to a
broken connection\). These dangling buffers get saved to
temporary files, making them a little less ephemeral. Nothing
else should be saved to this special temp directory, because
we'll use this location later to distinguish dangling buffers
even after they've been saved.  This way, after a clean exit from
emacs we can skip loading them by default next time.\n For other
notes, see `desktop-recover-doc-toc'.")

(defvar desktop-recover-doc-desktop-list ""
  "Many functions in this package work with a data-structure
typically called the \"desktop-list\". This describes the buffers
recorded in the .emacs-desktop file, which are candidates to be
re-loaded when desktop-recover-interactive is run.  The
desktop-list is a list of lists, with one row per buffer, where
each row is a list of (in this order): name, path, mode, and the
desktop-create-buffer call.  The \"name\" is the name sans path,
the \"path\" is the full-name, including path, the mode is the
name of the associated emacs mode (e.g. \"text-mode\"), and the
\"desktop-create-buffer call\" is the code (in string form) that
will need to be run to restore the buffer.\n
Note, the name \"path\" may be confusing: normally, I would call
this the \"full-name\", but in the case of dired buffers, a
directory is all it is, so we go by the more general name \"path\".
For other notes, see `desktop-recover-doc-toc'.
")

;;;;##########################################################################
;;;;  User Options, Variables
;;;;##########################################################################

(defgroup desktop-recover nil
  "Interactive recovery of Emacs status."
  :group 'desktop)

;; (defcustom desktop-recover-location user-emacs-directory
;;   "The default location from which we save and restore desktop files.
;; Defaults to `user-emacs-directory'.  Note: desktop.el has a
;; `desktop-dirname' variable, but that can not be used reliably as
;; a user setting, because the code changes it under some
;; circumstances."
;;   :type  'directory
;;   :group 'desktop-recover
;; )

(defvar desktop-recover-location user-emacs-directory
  "The default location from which we save and restore desktop files.
Defaults to `user-emacs-directory'.  Note: desktop.el has a
`desktop-dirname' variable, but that can not be used reliably as
a user setting, because the code changes it under some
circumstances.")
(put 'desktop-recover-location 'risky-local-variable t)

(defcustom desktop-recover-tmp-dir
  (concat desktop-recover-location "desktop-recover-tmp")
  "Location where dangling buffers that have no associated files are saved."
  :type  'directory
  :group 'desktop-recover
)
(put 'desktop-recover-tmp-dir 'risky-local-variable t)

(defvar desktop-recover-auto-save-count 1
  "Number of times auto-save-hook has fired.
Should be reset to zero when it exceeds the `desktop-recover-save-period'.")

(defcustom desktop-recover-save-period 3
  "Number of auto-saves when desktop will be saved.
You may wish to increase this number if your disk response
is slow."
  :type  'integer
  :group 'desktop-recover)

(defvar desktop-recover-compatible-desktop-versions '(206)
  "List of compatible desktop.el desktop file format versions.
These are the formats that we know desktop-recover.el can work with.")

(defvar desktop-recover-buffer-name "*Desktop Recover Menu*"
  "Buffer name for the desktop restore menu.")

(defvar desktop-recover-clean-exit-flag "desktop_recover_clean_exit.flag"
  "The existance of a file of this name signals that we did a clean exit.")

(defvar desktop-recover-suppress-save nil
  "Set this to t to over-ride any attempts at doing desktop saves.
Note: this flag is respected by desktop-recover.el code, not desktop.el.")

;; Bound locally in `desktop-read' in desktop.el
(defvar desktop-buffer-ok-count)
(defvar desktop-buffer-fail-count)

;;=======
;; routines common to save/read operations

(defun desktop-recover-fixdir (location &optional root)
  "Fixes up the file directory LOCATION.
Conditions directory paths for portability and robustness.
If the directory does not yet exist, it will be created.\n
Some examples (note that this always adds a trailing slash):
 '~/tmp'             => '/home/doom/tmp/'
 '~/tmp/../bin/test' => '/home/doom/bin/test/'\n
Relative paths are converted to absolute, using the current
`default-directory' setting, unless specified otherwise with the
ROOT option. As a side-effect: this converts the empty string into
`default-directory' or ROOT."
  (let ((location
         (substitute-in-file-name
          (convert-standard-filename
           (file-name-as-directory
            (expand-file-name location root))))))
    (unless (file-directory-p location)
      (make-directory location t))
    location))

;; This is used by: desktop-recover-force-save & desktop-recover-file-path
;; (and thus indirectly by: desktop-recover-interactive)
(defun desktop-recover-location (&optional dirname)
  "The standard behavior for choosing the desktop save location.
If DIRNAME is not given, defaults to `desktop-recover-location'
or the current `desktop-dirname' in that order.
Runs the result through \\[desktop-recover-fixdir], which
makes sure that it will exist. Sets `desktop-dirname' as a side-effect."
  (let* ((location  (desktop-recover-fixdir
                     (or
                      ;; If DIRNAME is given, use it.
                      (and (< 0 (length dirname)) dirname)
                      desktop-recover-location
                      desktop-dirname))))
    (setq desktop-dirname location) ;; makes sure desktop.el knows, too
    ))

;; This is used by: desktop-recover-interactive
(defun desktop-recover-file-path (&optional dirname)
  "Returns the full name and path of the desktop file.
The location is determined by the \\[desktop-recover-location]
function, and the name is determined by the `desktop-base-file-name'
variable.  Typically this will be \"~/.emacs.d/.emacs.desktop\".
This does not check for the existance of the file.
Note: \\[desktop-recover-location] sets `desktop-dirname' as a side-effect."
  (let* ((location (desktop-recover-location dirname))
         (full-name (concat
                      location
                      desktop-base-file-name)))
    full-name))

;;---------
;; managing the "clean save flag file"

(defun desktop-recover-flag-clean-exit ()
  "Create a flag file to indicate that we've done a clean exit.
Actually, this just flags the fact that we tried to exit cleanly:
there's no easy way to check if all saves were completed before
emacs died."
  (interactive)
  (let* ((clean-exit-flag-file
           (concat
            (desktop-recover-fixdir
             desktop-recover-tmp-dir)
            desktop-recover-clean-exit-flag))
         )
    (save-excursion
      (find-file clean-exit-flag-file)
      (insert " ")
      (save-buffer)
      )))

(defun desktop-recover-reset-clean-exit-flag ()
  "Erase the file used to flag that emacs exited cleanly."
  (let* (
         (tmp-dir (desktop-recover-fixdir
                   desktop-recover-tmp-dir))
         (clean-exit-flag-file
          (concat tmp-dir desktop-recover-clean-exit-flag))
         )
         (if (file-exists-p clean-exit-flag-file)
             (delete-file clean-exit-flag-file)
             )))

(defun desktop-recover-clean-exit-p ()
  "Does it look like emacs exited cleanly?"
  (let* (
         (tmp-dir (desktop-recover-fixdir
                   desktop-recover-tmp-dir))
         (clean-exit-flag-file
          (concat tmp-dir desktop-recover-clean-exit-flag))
         (retval (file-exists-p clean-exit-flag-file))
         )
    retval))

;;========
;; saving desktop files (with dangler management)
(defun desktop-recover-do-saves-automatically ()
  "Makes the desktop saved automatically using the auto-save-hook.
When exiting emacs intentionally, creates a flag file to indicate
we have exited cleanly."
;;  (add-hook 'auto-save-hook 'desktop-recover-save-with-danglers)
  (add-hook 'auto-save-hook 'desktop-recover-handle-auto-save)
  ;; remove flag file (it's re-created by doing a clean exit)
  (desktop-recover-reset-clean-exit-flag)
  (add-hook 'kill-emacs-hook 'desktop-recover-clean-up-for-exit))

(defun desktop-recover-stop-automatic-saves ()
  "Stops the desktop from being saved automatically via the auto-save-hook."
  (remove-hook 'auto-save-hook 'desktop-recover-handle-auto-save)
  (remove-hook 'kill-emacs-hook 'desktop-recover-clean-up-for-exit))

(defun desktop-recover-clean-up-for-exit ()
  "For doing a \"clean\" exit.
Intended to be attached to the kill-emacs-hook.
Saves off the desktop and creates the clean exit flag file."
  ;; (desktop-recover-stop-automatic-saves) ;; TODO is this needed at all?
  (desktop-recover-save-with-danglers)
  (desktop-recover-flag-clean-exit))

(defun desktop-recover-save-buffers-kill-terminal ()
  "For doing a \"clean\" exit.
Essentially a wrapper around save-buffers-kill-terminal.
This was intended to be bound to the usual keybinding for exiting emacs.
It is now deprecated, and should be unnecessary.
See \\[desktop-recover-do-saves-automatically]."
  (interactive)
  (desktop-recover-stop-automatic-saves)
  (desktop-recover-save-with-danglers)
  (desktop-recover-flag-clean-exit)
  (save-buffers-kill-terminal)
  )

(defun desktop-recover-handle-auto-save ()
  "Take the appropriate action if the auto-save-hook fires.
Saves the desktop state if the auto-save counter exceeds
the `desktop-recover-save-period'."
  (cond ((> desktop-recover-auto-save-count desktop-recover-save-period)
         (setq desktop-recover-auto-save-count 1)
         (desktop-recover-save-with-danglers)
        )
        (t
         (setq desktop-recover-auto-save-count (+ 1 desktop-recover-auto-save-count))
         )))

(defun desktop-recover-save-with-danglers ()
  "Save desktop preserving buffers that have no associated files.
Works by saving these danglers to a standard temp directory, then
uses desktop.el to save them along with the other open files.  After
re-starting emacs, you should then have buffers corresponding to
the old dangling buffers (though now they'll be associated with
files in the temp location).  The temp location is specified by
`desktop-recover-tmp-dir'. See: `desktop-recover-doc-dangling-buffers'"
  (interactive)
  (let* ((preserve-buffer (current-buffer))
         (temp-loc
          (desktop-recover-fixdir desktop-recover-tmp-dir))
         (dangling-buffers (desktop-recover-list-dangling-buffers))
         )
    (unless (file-exists-p temp-loc)
      (make-directory temp-loc t))
    ;; save all to temp location using a file name identical to the buffer name
    (dolist (buffy dangling-buffers)
            (set-buffer buffy)
            (let* ((buffy-name (buffer-name  buffy))
                   (file-nameo (concat temp-loc "/" buffy-name))
                   )
              (write-file file-nameo)
              ))
    (switch-to-buffer preserve-buffer)
    (deactivate-mark)
    (desktop-recover-force-save)
  ))

;; Note: used by desktop-recover-save-with-danglers
(defun desktop-recover-list-dangling-buffers ()
  "List buffers without files or directories, skipping internal and display buffers.
Returns a list of buffer objects."
  (interactive)
  (save-excursion
  (let* ((initial-buffer (current-buffer))
         (ordinaries-list (desktop-recover-list-ordinary-buffers))
         (output-list)
         )
    (save-excursion
      (dolist (buffy ordinaries-list)
        (set-buffer buffy) ;; switch to buffer so we can check 'major-mode'
        (let* ((file-nameo (buffer-file-name buffy) )
               (buffy-name (buffer-name  buffy) )
               )
          (cond ((not file-nameo) ;; looking for buffers without file names
                 (push buffy output-list)
                 )
                )))
      (switch-to-buffer initial-buffer)
      (deactivate-mark)
  output-list))))

;; Note: used by desktop-recover-list-dangling-buffers
;; and hence by desktop-recover-save-with-danglers
(defun desktop-recover-list-ordinary-buffers ()
  "List buffers, skips: dired, shell, debugger, internal and display buffers.
Returns a list of buffer objects.  Note that 'ordinary' buffers include
'dangling' buffers without associated files."
  (interactive)
  (let* ((initial-buffer (current-buffer))
         (output-list)
         )
    (save-excursion
      (dolist (buffy (buffer-list))
        (set-buffer buffy) ; switch to buffer so we can check 'major-mode'
        (let* ((file-nameo (buffer-file-name buffy))
               (buffy-name (buffer-name buffy))
               )
          (cond ((and
                  ;; Skip directories
                  (not (string= major-mode "dired-mode"))
                  ;; Skip internal buffers (begin with space)
                  (not (string= (substring buffy-name 0 1) " "))
                  ;; Skip dynamic display buffers (begin with asterix)
                  (not (string= (substring buffy-name 0 1) "*"))
                  ;; Skip shell and debugger buffers (even without leading "*")
                  (not (or
                        (string= major-mode "shell-mode")
                        (string= major-mode "eshell-mode")
                        (string= major-mode "gud-mode")))
                  ;; Skip the desktop file itself
                  (not (string= file-nameo (desktop-recover-file-path)))
                  )
                 (push buffy output-list)
                 )
                )))
      (switch-to-buffer initial-buffer)
      (deactivate-mark)
      output-list)))

;; currently, this is not used directly by desktop-recover.el
(defun desktop-recover-break-file-association-of-danglers ()
  "Remove association between dangling buffers and temp files.
We can distinguish between \"real\" buffers and ones that are
dangling-but-saved by the fact that they've been saved to
`desktop-recover-doc-tmp-dir'. See `desktop-recover-dangling-buffers'."
  (interactive)
  (let* ((preserve-buffer (current-buffer))
         (temp-loc (desktop-recover-fixdir desktop-recover-tmp-dir))
         (buffers (desktop-recover-list-ordinary-buffers))
              ;; includes real danglers, as well as saved ones
         (location)
         (dangling-content-list)
              ;; list of lists: buffer name paired with content
         )
    ;; breaking file associations of any buffers saved to temp-loc
    (dolist (buffy buffers)
      (setq location (file-name-directory (buffer-file-name buffy)))
      (cond ((string= temp-loc location)
             (set-buffer buffy)
             (let ((name (buffer-name)))
               (set-visited-file-name nil)
               ;; (rename-buffer name) ;; doesn't seem to be necessary
               )
             )))
    (switch-to-buffer preserve-buffer)
    (deactivate-mark)
  ))

(defun desktop-recover-save-without-danglers ()
  "Desktop autosave routine that skips dangling buffers of any vintage.
This means that it screens out the ones that have been made less ephemeral
by associating them with files in the standard tmp directory.
See: `desktop-recover-doc-dangling-buffers'"
  (interactive)
  (desktop-recover-break-file-association-of-danglers)
  (desktop-recover-force-save))

;;--------
;; interactive commands to manipulate the save period

(defun desktop-recover-increase-save-period (&optional delta)
  "Increases the save period, `desktop-recover-save-period'.
By default, increases the save period by 1.
When run interactively, a numeric prefix argument may be used to
indicate how much to increase the period \(e.g. a C-u prefix will
increase by 4\).  When run from a program, the argument DELTA
should be a numeric value.  In either case, the numeric value may
be negative, to reduce the save period.
The \"save period\" is the number of auto-saves that must
occur before the desktop state is saved.  You might wish
to increase this period if your disk response seems sluggish."
  (interactive "P")
  (if (listp delta)
      (setq delta (car delta)))
  (unless (number-or-marker-p delta)
    (setq delta 1))
  (setq desktop-recover-save-period
        (+ desktop-recover-save-period delta))
  (message "The desktop-recover-save-period is now %d" desktop-recover-save-period))

;; Yes, a redundant function, but having this is convenient.
(defun desktop-recover-decrease-save-period (&optional delta)
  "Decrease the save period.  See: \\[desktop-recover-increase-save-period]."
  (interactive "P")
  (if (listp delta)
      (setq delta (car delta)))
  (unless (number-or-marker-p delta)
    (setq delta 1))
  (setq desktop-recover-save-period
        (- desktop-recover-save-period delta))
  (message "The desktop-recover-save-period is now %d" desktop-recover-save-period))

;; --------
;; desktop-recover.el save primitives (all other "saves" use these internally)

(defun desktop-recover-force-save (&optional dirname)
   "Force save of desktop by wiping out any existing file first.
This ensures you will not have any questions getting in the way
about modification times, etc.  If DIRNAME is not given, defaults
to `desktop-recover-location' or the current `desktop-dirname' in
that order.  See: `desktop-recover-doc-philosophy'."
   (let* ((location (desktop-recover-location dirname))
          )
     (cond ((not desktop-recover-suppress-save)
            (setq desktop-dirname
                  (file-name-as-directory (expand-file-name location)))
            (desktop-release-lock) ;; just being neat
            (desktop-remove)
            (desktop-save location)
            (message "Saved desktop in %s" location)
            )
           (t
            (message
             "Desktop save skipped: desktop-recover-suppress-save is set"))
           )))

;;--------
;; window management utilities

;; not currently in use
(defun desktop-recover-list-in-other-window (list buffer-name)
  "Displays LIST of strings in BUFFER-NAME in a second window.
Closes all other windows except for the current window and the
newly created one."
  (unless
      (desktop-recover-buffer-safe-to-overwrite-p buffer-name)
    (error (format "%s does not look safe to overwrite." buffer-name)))
  (delete-other-windows)
  (split-window-vertically)
  (other-window 1)
  (switch-to-buffer buffer-name)
  (mark-whole-buffer)
  (delete-region (mark) (point))
  (insert (mapconcat 'identity list "\n"))
  (deactivate-mark))

;; used by desktop-recover-show-menu
(defun desktop-recover-buffer-safe-to-overwrite-p (buffer-name)
  "Verify that a buffer is safe to be over-written.
Currently this is just a check to make sure the given name
follows the convention for dynamic display buffers: it must
begin with a leading asterix."
  (string= (substring buffer-name 0 1) "*"))

;;========
;; read desktop files

;; desktop.el's desktop-read just loads the whole .emacs-desktop
;; elisp file, but to handle each file recovery conditionally,
;; we need to parse the .emacs-desktop ourselves
(defun desktop-recover-interactive (&optional dirname)
  "Read the .emacs-desktop file, bring up menu to approve buffer restoration."
  (interactive "Dload desktop file from:")
  (desktop-save-mode -1)               ;; Turn desktop.el off, we use indirectly
  (setq desktop-load-locked-desktop t) ;; Sounds good. Does it do anything?
  (setq inhibit-startup-screen t)      ;; Keep splash screen out of the way.
  (let* ((desktop-file (desktop-recover-file-path dirname))
         ;; an .emacs-desktop file is in sections labeled like so:
         (global-section-marker ";; Global section")
         (buffer-section-marker ";; Buffer section")
         ;; prepend ^ to make them regexps
         (global-section-pattern
          (concat "^" global-section-marker))
         (buffer-section-pattern
          (concat "^" buffer-section-marker))
         (global-section "")
         (buffer-section "")
         (desktop-list)  ;; list of lists, one row for each desktop buffer
         )
    (cond ((file-exists-p desktop-file)
           (message "desktop-recover-interactive reading from: %s" desktop-file)
           (find-file desktop-file)
           ;; check file format version, warn if looks wrong.
           (desktop-recover-desktop-version-format)
           ;; parse into global and buffer sections
           (goto-char (point-min))
           (re-search-forward global-section-pattern)
           (forward-line 1)
           (let* ((beg (point) )
                  (end))
             (re-search-forward buffer-section-pattern)
             (previous-line 1)
             (move-end-of-line 1)
             (setq end (point))
             (setq global-section (buffer-substring-no-properties beg end)))
           (forward-line 2)
           (let* ((beg (point) )
                  (end (point-max)))
             (setq buffer-section (buffer-substring-no-properties beg end)))
           (eval (read global-section))
           (setq desktop-list
                 (desktop-recover-parse-buffer-section buffer-section))
           ;; display the desktop-list in an interactive selection buffer
           (desktop-recover-show-menu desktop-list)
           )
          (t
           (desktop-recover-do-saves-automatically))
          )
    ))

(defun desktop-recover-parse-buffer-section (buffer-section)
  "Associate file system names with desktop-create-buffer code.
Parses the 'buffer section' of a .emacs.desktop file (passed in
as the string BUFFER-SECTION) subdividing it into desktop-create-buffer
function calls, and picking out names from them to use for user
confirmation.  Returns the desktop-list, a list of lists, with
one row per buffer, where each row is a list (in this order) of:
name, path, mode, and the desktop-create-buffer call.
See \\[desktop-recover-doc-desktop-list]."
  (let* ((dcb-string "(desktop-create-buffer")
         (dcb-pattern (format "^[ \t]*?%s[ \t]" dcb-string))
         (dcb-list)
         (dcb-lines)
         (file-format)
         (mode)
         (file-name)  ;; full name, with path
         (name)       ;; file/dir name without path
         (misc)       ;; a list of stuff... multiple paths for tree dired?
         (first-misc) ;; the primary dir in dired-mode (with trailing slash)
         (path)
         (record)
         (desktop-list)
         )
    ;; here we split on the initial funcall string, then prepend it again
    ;; to have the list of complete function calls
    (setq dcb-list
          (mapcar (lambda (item)
                    (concat dcb-string " "
                            (substring-no-properties item)))
                  (split-string buffer-section dcb-pattern t)))
    (dolist (dcb-code dcb-list)
      ;; the dcb-code handled as a list of lines
      (setq dcb-lines (split-string dcb-code "\n" t))
      (setq file-format (car (cdr (split-string (nth 0 dcb-lines) " " t))))
      (setq file-name (desktop-recover-clean-string (nth 1 dcb-lines)))
      (setq name (desktop-recover-clean-string (nth 2 dcb-lines)))
      (setq mode (desktop-recover-clean-string (nth 3 dcb-lines)))
      (setq misc (nth 8 dcb-lines))  ;; will need extra clean?
      ;;
      (cond ((string= mode "dired-mode")
             (setq first-misc (desktop-recover-snag-first-item misc))
             (setq path first-misc))
            ((string= mode "Info-mode")
             (setq first-misc (desktop-recover-snag-first-item misc))
             (let ((info-name (nth 1 (eval (read misc)))))
               (setq name (concat name " " info-name))
               ))
            (t
             (setq path file-name)
             ))
      (setq record
            (append
             (mapcar 'eval
                     '(name path mode dcb-code))
             record))
      (setq desktop-list (cons record desktop-list))
      )
    desktop-list))

(defun desktop-recover-clean-string (string)
  "Do some common, quick-and-dirty string clean-up operations.
Strips leading/trailing whitespace, bracketing double-quotes, and
also any leading single-quotes."
  (let ((strip-lead-space-pattern      "^[ \t]*\\([^ \t]*.*\\)" )
        (strip-trail-space-pattern     "\\(.*?\\)[ \t]*$"       )
        (strip-lead-apostrophe-pattern "^'*\\(.*\\)"            )
        (strip-lead-quote-pattern      "^\"*\\(.*\\)"           )
        (strip-trail-quote-pattern     "\\(.*?\\)\"*$"          )
        )
    (cond (string  ;; skip everything if string is nil
       (setq string
              (cond ((string-match strip-lead-space-pattern string)
                     (match-string 1 string))
                    (t
                     string)))
      (setq string
            (cond ((string-match strip-trail-space-pattern string)
                   (match-string 1 string))
                  (t
                   string)))
      (setq string
            (cond ((string-match strip-lead-apostrophe-pattern string)
                   (match-string 1 string))
                  (t
                   string)))
      (setq string
            (cond ((string-match strip-lead-quote-pattern string)
                   (match-string 1 string))
                  (t
                   string)))
      (setq string
            (cond ((string-match strip-trail-quote-pattern string)
                   (match-string 1 string))
                  (t
                   string)))
      ;; odd hack:  can we have files and such named "nil" now?
      (setq string
            (cond ((string-match "^nil$" string)
                   nil)
                  (t
                   string)))
      ))
    string))

(defun desktop-recover-snag-first-item (list-string)
  "Get's the first item out of the list stored in LIST-STRING.
Intended to deal with the 'desktop-buffer-misc' field of a
desktop-create-buffer call.
This may look something like:
  '(\"/home/doom/End/Pit/\")
Note: This is not just a wrapper around \"car\", it does the
conversion from string to list first."
  (let* ((list (eval (read list-string)))
         (first-item (car list))
         )
    first-item))

;; There are two places we can look for the desktop file format version:
;; (1) the comment near the top of the file:
;;      ;; Desktop file format version 206
;; (2) on each dcb call:
;;     (desktop-create-buffer 206
(defun desktop-recover-desktop-version-format ()
  "Find the desktop file format version number.
Presumes the current buffer it a desktop file \(typically \".emacs.desktop\"\).
Tries to find the version number in one of two places \(1\) the comment
near the top of the file, or \(2\) the first desktop-create-buffer call.
Returns the best version of the two, or nil only if it can't find any
version on the compatibility list.  Issues warning messages if anything
looks funny."
  ;; (interactive) ;; DEBUG
  (let* ((compatible-versions desktop-recover-compatible-desktop-versions)
         (scraped-version-1)
         (scraped-version-2)
         (ok-1)
         (ok-2)
         (version-1-pattern ";; Desktop file format version \\([0-9]+\\)")
         (version-2-pattern "(desktop-create-buffer \\([0-9]+\\)")
         )
    (save-excursion
      (goto-char (point-min))
      (if (re-search-forward version-1-pattern nil t)
          (setq scraped-version-1 (string-to-number (match-string-no-properties 1))))
      (goto-char (point-min))
      (if (re-search-forward version-2-pattern nil t)
          (setq scraped-version-2 (string-to-number (match-string-no-properties 1))))
      (setq ok-1
            (member scraped-version-1 compatible-versions))
      (setq ok-2
            (member scraped-version-2 compatible-versions))
      (cond ((and (and ok-1 ok-2) (equal scraped-version-1 scraped-version-2))
             ;; all ok, return the version
             scraped-version-1)
            ((and (and ok-1 ok-2) (not (equal scraped-version-1 scraped-version-2)))
             (message "Two desktop file format versions found, but both okay: %d %d"
                      scraped-version-1 scraped-version-2)
             ;; return *a* version
             scraped-version-1)
            ((or ok-1 ok-2)
             (message "Ambiguous desktop file format version check: only one looks right: %d %d."
                      scraped-version-1 scraped-version-2)
             ;; return the version that looks right
             (cond (ok-1
                    scraped-version-1)
                   (ok-2
                    scraped-version-2)))
            (t
             (message "Desktop file version not on compatibility list for desktop-recover.el: %d %d"
                      scraped-version-1 scraped-version-2)
             nil)
            ))))

(defvar desktop-recover-last-desktop-list ()
  "A cache of the desktop-list used by \\[desktop-recover-show-menu].")

;; this is run from desktop-recover-interactive at emacs init time
;; (it is not currently bound to a key)
(defun desktop-recover-show-menu (desktop-list)
  "Displays info about buffers that are candidates to be restored.
These are buffers that existed when the last desktop save was done.
If run interactively, will re-display the most-recently used desktop-list."
  (interactive
   (list desktop-recover-last-desktop-list))
  (let ((buffer-name desktop-recover-buffer-name))
    (unless
        (desktop-recover-buffer-safe-to-overwrite-p buffer-name)
      (error (format "%s does not look safe to overwrite." buffer-name)))
    (let* ((menu-contents))
      (setq menu-contents (desktop-recover-build-menu-contents desktop-list))
      (switch-to-buffer buffer-name)
      (setq buffer-read-only nil)
      (delete-region (point-min) (point-max))
      (insert menu-contents)
      (forward-line 1)
      (deactivate-mark)
      (desktop-recover-mode)
      (setq truncate-lines t)
      (setq buffer-read-only 't)
      (goto-char (point-min))
      (forward-line 1)
      )
    ;; make sure auto desktop saves don't happen until after recovery.
    (desktop-recover-stop-automatic-saves)
    ;; save this for interactive re-display purposes
    (setq desktop-recover-last-desktop-list desktop-list)
    ))

;;========
;; interactive menu for selecting what to recover

;; Display a list of marker, name, path, mode,
;; where the marker is set ("*") if buffer is to be loaded,
;; The return key is the "do-it" that accepts the displayed settings,
;; and the "m" and "u" keys control whether the current line is set

(defgroup desktop-recover-faces nil
  "Typefaces used in the interactive desktop-recover menu."
  :group 'desktop-recover
  :group 'faces)

(defface desktop-recover-heading-face
  '((((class color)
      (background light))
     (:foreground "black"))
    (((class color)
      (background dark))
     (:foreground "white")))
  "Face used for displaying the heading of the desktop-recover menu."
  :group 'desktop-recover-faces)

(defface desktop-recover-dired-face
  '((((class color)
      (background light))
     (:foreground "DarkGoldenrod4" :bold t))
    (((class color)
      (background dark))
     (:foreground "DarkGoldenrod2" :bold t))
    (t
     (:bold t)))
  "Face used for displaying dired-mode entires in desktop-recover menu."
  :group 'desktop-recover-faces)

(defface desktop-recover-perl-face
  '((((class color)
      (background light))
     (:foreground "forest green"))
    (((class color)
      (background dark))
     (:foreground "light green")))
  "Face used for displaying perl mode entries in the desktop-recover menu."
  :group 'desktop-recover-faces)

(defface desktop-recover-sh-face
  '((((class color)
      (background light))
     (:foreground "khaki1"))
    (((class color)
      (background dark))
     (:foreground "khaki4")))
  "Face used for displaying sh-mode entries in the desktop-recover menu."
  :group 'desktop-recover-faces)

(defface desktop-recover-text-face
  '((((class color)
      (background light))
     (:foreground "RoyalBlue4"))
    (((class color)
      (background dark))
     (:foreground "RoyalBlue1")))
  "Face used for displaying text-mode entries in the desktop-recover menu."
  :group 'desktop-recover-faces)

(defface desktop-recover-fundamental-face
  '((((class color)
      (background light))
     (:foreground "PaleVioletRed4"))
    (((class color)
      (background dark))
     (:foreground "PaleVioletRed1")))
  "Face used for displaying fundamental-mode entries in the desktop-recover menu."
  :group 'desktop-recover-faces)

(defface desktop-recover-emacs-lisp-face
  '((((class color)
      (background light))
     (:foreground "MediumPurple4"))
    (((class color)
      (background dark))
     (:foreground "MediumPurple1")))
  "Face used for displaying elisp entries in the desktop-recover menu."
  :group 'desktop-recover-faces)

(defmacro desktop-recover-make-face (name char color1 color2)
  `(defface ,name
  '((((class color)
      (background light))
     (:foreground ,color1))
    (((class color)
      (background dark))
     (:foreground ,color2)))
  ,(format "Face used for modes beginning with %s." char)
  :group 'desktop-recover-faces
  ))

(desktop-recover-make-face desktop-recover-a-face "a" "DarkOrange4" "DarkOrange1")
(desktop-recover-make-face desktop-recover-b-face "b" "orange4" "orange1")
(desktop-recover-make-face desktop-recover-c-face "c" "gold4" "gold1")
(desktop-recover-make-face desktop-recover-d-face "d" "DarkOrchid4" "DarkOrchid1")
(desktop-recover-make-face desktop-recover-f-face "e" "chartreuse4" "chartreuse1")
(desktop-recover-make-face desktop-recover-f-face "f" "green4" "green1")
(desktop-recover-make-face desktop-recover-g-face "g" "SpringGreen4" "SpringGreen1")
(desktop-recover-make-face desktop-recover-h-face "h" "cyan4" "cyan1")
(desktop-recover-make-face desktop-recover-i-face "i" "OliveDrab4" "OliveDrab1")
(desktop-recover-make-face desktop-recover-j-face "j" "DeepSkyBlue4" "DeepSkyBlue1")
(desktop-recover-make-face desktop-recover-k-face "k" "blue4" "blue1")
(desktop-recover-make-face desktop-recover-l-face "l" "magenta4" "magenta1")
(desktop-recover-make-face desktop-recover-m-face "m" "DarkOliveGreen4" "DarkOliveGreen1")
(desktop-recover-make-face desktop-recover-n-face "n" "PaleGreen4" "PaleGreen1")
(desktop-recover-make-face desktop-recover-o-face "o" "DarkSeaGreen4" "DarkSeaGreen1")
(desktop-recover-make-face desktop-recover-p-face "p" "DeepPink4" "DeepPink1")
(desktop-recover-make-face desktop-recover-q-face "q" "SeaGreen4" "SeaGreen1")
(desktop-recover-make-face desktop-recover-r-face "r" "aquamarine4" "aquamarine1")
(desktop-recover-make-face desktop-recover-s-face "s" "maroon4" "maroon1")
(desktop-recover-make-face desktop-recover-t-face "t" "coral4" "coral1")
(desktop-recover-make-face desktop-recover-u-face "u" "salmon4" "salmon1")
(desktop-recover-make-face desktop-recover-v-face "v" "LightSalmon4" "LightSalmon1")
(desktop-recover-make-face desktop-recover-w-face "w" "CadetBlue4" "CadetBlue1")
(desktop-recover-make-face desktop-recover-x-face "x" "chocolate4" "chocolate1")
(desktop-recover-make-face desktop-recover-y-face "y" "PeachPuff4" "PeachPuff1")
(desktop-recover-make-face desktop-recover-z-face "z" "tan4" "tan1")

(defvar desktop-recover-marker "*"
  "Symbol used to show a buffer will be reloaded \(typically \"*\"\).")

(defvar desktop-recover-auto-save-marker "#"
  "Symbol to show that a more recent auto-save file exists \(typically \"#\"\).")

(defvar desktop-recover-unmarker " "
  "Character used to erase either of the above markers (typically a space).")

;;--------
;; the view: display the info about buffers which may be re-loaded

(defun desktop-recover-build-menu-contents (desktop-list)
  "Builds the menu text from the DESKTOP-LIST data."
  (let* ((name) (path) (mode) (dcb-code)
        (marker desktop-recover-marker)     ;; "*"
        (unmarker desktop-recover-unmarker) ;; " "
        (auto-save-mark desktop-recover-auto-save-marker) ;; "#"
        (line "")
        (line-fmt (desktop-recover-menu-format desktop-list))
        (marker-field)
        (auto-save-field)
        (hint-mess (concat
                    "Hit Enter to open marked buffers."
                    "To mark: \"*\" Unmark: \"u\" "
                    "Toggle auto-save: \"#\"" "\n"))
        (menu-contents "")
        )
    ;; colorize the heading line
    (put-text-property 0 (length hint-mess)
                       'face 'desktop-recover-heading-face
                       hint-mess)
    (setq menu-contents hint-mess)
    (dolist (record desktop-list)
      ;; unpack the record
      (setq name     (nth 0 record))
      (setq path     (nth 1 record))
      (setq mode     (nth 2 record))
      (setq dcb-code (nth 3 record))
      (setq marker-field
            (cond ((desktop-recover-by-default-p record)
                   desktop-recover-marker)
                  (t
                   desktop-recover-unmarker)
                  ))
      (setq auto-save-field
            (cond ((desktop-recover-newer-auto-save path)
                   auto-save-mark)
                  (t
                   desktop-recover-unmarker)
                  ))
      (let ((visible-path path)
            (visible-name name)
            )
        (cond ((not path) ;; must be an odd buffer (e.g. "*info*")
               (setq visible-path "")
               (message "looks like a nil path: %s" path)
               )
              ((string= mode "dired-mode") ;; looks like a directory
               (setq visible-path
                     (replace-regexp-in-string "[^/]*/$" "" visible-path))
               (setq visible-path
                     (replace-regexp-in-string "/$" "" visible-path))
               )
              (t ;; not a directory
               (setq visible-path (file-name-directory path))
               (setq visible-path
                     (replace-regexp-in-string "/$" "" visible-path))
               ))
        (setq visible-path
              (replace-regexp-in-string
               (concat "^" (getenv "HOME"))
               "~" visible-path))
        (setq visible-path (desktop-recover-choose-faces visible-path mode))
        (setq visible-name (desktop-recover-choose-faces visible-name mode))
        (setq line (format
                    line-fmt
                    marker-field
                    auto-save-field
                    visible-name
                    visible-path
                    )))
      ;; saving the dcb code block out-of-sight, attached to first character
      (put-text-property 0 1 'dcb dcb-code line)
      ;; preserving all the visible fields also
      (put-text-property 0 1 'name name line)
      (put-text-property 0 1 'path path line)
      (put-text-property 0 1 'mode mode line)
      (put-text-property 0 1 'marker marker-field line)
      (put-text-property 0 1 'auto-save auto-save-field line)
      (setq menu-contents
            (concat menu-contents line "\n")
      ))
    menu-contents))

(defun desktop-recover-choose-faces (string mode)
  "Apply an appropriate face to STRING, given the MODE name.
Some modes are special cases with particular faces associated
with them, for the others, we look at the first character
of the mode name, and use it to choose a generic face."
  (cond ((string= mode "dired-mode")
         (put-text-property 0 (length string)
                            'face 'desktop-recover-dired-face
                            string))
        ((string-match "^[c]*perl-mode$" mode)
         (put-text-property 0 (length string)
                            'face 'desktop-recover-perl-face
                            string))
        ((string= mode "sh-mode")
         (put-text-property 0 (length string)
                            'face 'desktop-recover-sh-face
                            string))
        ((string= mode "emacs-lisp-mode")
         (put-text-property 0 (length string)
                            'face 'desktop-recover-emacs-lisp-face
                            string))
        ((string= mode "text-mode")
         (put-text-property 0 (length string)
                            'face 'desktop-recover-text-face
                            string))
        ((string= mode "fundamental-mode")
         (put-text-property 0 (length string)
                            'face 'desktop-recover-fundamental-face
                            string))
        (t
         (let* ((first-char    (downcase (substring mode 0 1)))
                (face-name     (format "desktop-recover-%s-face" first-char))
                (generic-face  (read face-name))
                )
           (if (string-match "^[a-z]$" first-char)
               (put-text-property 0 (length string)
                                  'face generic-face
                                  string))
           )))
  string)

;; four fields: marker auto-save-marker name  path
(defun desktop-recover-menu-format (desktop-list)
  "Generate the menu format, balancing between lengths of name and path."
  (let* ((name) (path) (width-name) (width-path)
         (total-width (frame-width))
         (max-name 0)
         ;; (max-path 0)    ;; Not making any use of max-path at present
         (line-fmt "")
         )
    (dolist (record desktop-list)
      (setq name     (nth 0 record))
      (setq path     (nth 1 record))
      (if (> (length name) max-name)
          (setq max-name (length name)))
      ;; (if (> (length path) max-path)
      ;; (setq max-path (length path)))
        )
    ;; Goal: (line-fmt " %1s %1s %-33s%-42s")
    (setq width-name (+ max-name 2))
    (setq width-path (- total-width 6 width-name))
    (setq line-fmt
          (concat
           " %1s %1s %-"
           (number-to-string width-name)
           "s%-"
           (number-to-string width-path)
           "s"))
    line-fmt))

;; TODO this could use the mode to do mode based selection defaults.
;; You might like to have dired off by default? Or filter shell buffers
;; at this stage, not when saving the desktop.  So, define a list of modes
;; to ignore, where the default is just dired-mode?
(defun desktop-recover-by-default-p (record)
  "Examine RECORD to determine if this buffer should be reloaded by default.
A file should not be re-loaded if was an automatically saved temporary
buffer and emacs exited cleanly.  RECORD should be a list of
name, path, mode and dcb-code.  Always returns nil if path is nil."
  (let* ((tmp-dir   (desktop-recover-fixdir desktop-recover-tmp-dir))
         ;; unpack the record
         (name      (nth 0 record))
         (path      (nth 1 record))
         (mode      (nth 2 record))
         (dcb-code  (nth 3 record))
         (location)
         (recover-p) ;; return value
         )
    ;; just return nil if path is nil
    (unless (not path)
        (progn
           (setq location (desktop-recover-fixdir (file-name-directory path)))
           (setq recover-p
                 (cond ((string= location tmp-dir) ;; a preserved dangler
                        (cond ((desktop-recover-clean-exit-p)
                               nil)
                              (t
                               t)))
                       (t t)))))
    recover-p))

(defun desktop-recover-newer-auto-save (path)
  "Given PATH (full path and file name) check for newer auto-save file."
  (cond
   (path
    (let* (
           (path (desktop-recover-clean-string path))
           (name (cond (path
                        (file-name-nondirectory path))))
           (loc  (cond (path
                        (file-name-directory path))))
           (a-s-name (format "#%s#" name))
           (auto-save (concat loc a-s-name))
           )
      ;; if autosave does not exist, this is nil
      (file-newer-than-file-p auto-save path)
      ))
   (t
    nil)
   ))

;;--------
;; the controller: a simple mode to handle selection of buffers to be restored.

(define-derived-mode desktop-recover-mode
  text-mode "desktop-recover"
  "Major mode to display candidates for buffers to be restored when re-starting emacs.
\\{desktop-recover-mode-map}"
  (use-local-map desktop-recover-mode-map)
  )

(define-key desktop-recover-mode-map "\C-m" 'desktop-recover-do-it)
(define-key desktop-recover-mode-map "m"  'desktop-recover-mark-move-down)
(define-key desktop-recover-mode-map "u"  'desktop-recover-unmark-move-down)
(define-key desktop-recover-mode-map "n"  'next-line)
(define-key desktop-recover-mode-map "p"  'previous-line)
(define-key desktop-recover-mode-map "*"  'desktop-recover-mark-move-down)
(define-key desktop-recover-mode-map "#"  'desktop-recover-toggle-hash-move-down)

(defun desktop-recover-do-it ()
  "Accept the current settings of the restore menu buffer.
Runs the appropriate \"desktop-create-buffer\" calls stored
in the desktop-list data structure.  Follows up
with auto-save file recovery, if that's indicated."
;; An implementation quirk: the text displayed to the user has little
;; to do with the values that we read in here, instead it uses the
;; "hidden" fields attached to the text properties of the first
;; character of the line.  The one exception is the asterix used to
;; mark a line as active.  We search for the visible asterix to find
;; the next line to process.
  (interactive)
  (let* (
         (recover-list-buffer (current-buffer))
         (desktop-recover-suppress-save t) ;; No point in saving during load
         (marker-pattern
          (concat "^[ \t]"
                  desktop-recover-marker
                  "\\*")) ;; line begins with asterix
         (auto-save-pattern desktop-recover-auto-save-marker)
         ;; must imitate the context of dcb calls in desktop.el
         ;; (even though we don't care about these features).
         (desktop-first-buffer nil)
         (desktop-buffer-ok-count 0)
         (desktop-buffer-fail-count 0)
         (owner (desktop-owner))
         )
    ;; now we do all of the lines
    ;; note: this sweeps bottom-to-top
    (goto-char (point-max))
    (while ;; loop over all lines in buffer
        (progn
          (save-excursion
            (move-beginning-of-line 1)
            ;; if line is marked with an asterix...
            (cond ((thing-at-point-looking-at marker-pattern)
                   (let*
                       (
                        ;; unpacking info stashed in 1st char properties
                        (dcb-code  (eval (get-char-property (point) 'dcb)))
                        (auto-save (get-char-property (point) 'auto-save))
                        ;; (mode (eval (get-char-property (point) 'mode)))
                        (name (get-char-property (point) 'name))
                        (path (get-char-property (point) 'path))
                        )
                     ;; do it to it (and keep going if there are problems)
                     (condition-case nil
                         (eval (read dcb-code))
                       (error
                        (message "Problem recovering %s %s" name path)))
                     ;; check for auto-save file, recover if indicated
                     (cond ((not (string-match "/$" path)) ;; not a directory
                            (cond ((and
                                    (desktop-recover-newer-auto-save path)
                                    (string-match auto-save-pattern auto-save))
                                   (desktop-recover-recover-file path)
                                   ))
                            ))
                     )))
            ) ;; end save-excursion
          (previous-line 1)
          (>= (line-number-at-pos) 2)
          )) ;; end while-progn -- all menu lines done
    (desktop-recover-do-saves-automatically)
    (bury-buffer recover-list-buffer) ;; ok to leave around, but let's bury it
    (list-buffers)
    (other-window 1)
    (goto-char (point-min))
    (other-window -1)
    ))

(defun desktop-recover-mark ()
  "Set the marker for the current line: add leading asterix."
  ;; TODO any reason to avoid hardcoding putting it in column 2?
  (interactive)
  (save-excursion
  (setq buffer-read-only nil)
    (move-beginning-of-line 1)
    (forward-char 1)
    (delete-char 1)
    (insert desktop-recover-marker)
    (setq overwrite-mode nil)
    (setq buffer-read-only 't)
  ))

(defun desktop-recover-unmark ()
  "Unset the marker for the current line: remove leading asterix."
  ;; TODO better to search for the asterix, no?  This assumes it's in col 2.
  (interactive)
  (save-excursion
  (setq buffer-read-only nil)
    (move-beginning-of-line 1)
    (forward-char 1)
    (delete-char 1)
    (insert desktop-recover-unmarker)
    (setq overwrite-mode nil)
    (setq buffer-read-only 't)
  ))

(defun desktop-recover-mark-move-down ()
  "Set marker on the current line, move down one."
  (interactive)
  (desktop-recover-mark)
  (forward-line 1))

(defun desktop-recover-unmark-move-down ()
  "Unset marker of the current line, move down one."
  (interactive)
  (desktop-recover-unmark)
  (forward-line 1))

(defun desktop-recover-toggle-hash ()
  "Toggle the auto-save \(\"#\"\) marker for the current line.
Will not turn this mark on unless there really is a newer auto-save file."
  (interactive)
  (save-excursion
    (setq buffer-read-only nil)
    (move-beginning-of-line 1)
    (let* (;; unpacking info stashed in 1st char properties
           (status (eval (get-char-property (point) 'auto-save)))
           ;; (dcb-code  (eval (get-char-property (point) 'dcb)))
           ;; (mode (eval (get-char-property (point) 'mode)))
           (name (eval (get-char-property (point) 'name)))
           (path (eval (get-char-property (point) 'path)))
           )
      (cond ((string= status desktop-recover-auto-save-marker)
             ;; search for hash mark
             (search-forward desktop-recover-auto-save-marker)
             (backward-char 1)
             ;; replace with desktop-recover-unmarker
             (delete-char 1)
             (insert desktop-recover-unmarker)
             ;; modify text property
             (setq status desktop-recover-unmarker)
             (move-beginning-of-line 1)
             (put-text-property (point) (1+ (point)) 'auto-save status)
             )
            ((and
              (string= status desktop-recover-unmarker)
              (desktop-recover-newer-auto-save path))
             ;; step to hash marker field (no easy way to avoid hardcoding)
             (forward-char 3)
             ;; replace with desktop-recover-auto-save-marker
             (delete-char 1)
             (insert desktop-recover-auto-save-marker)
             ;; modify text property
             (setq status desktop-recover-auto-save-marker)
             (move-beginning-of-line 1)
             (put-text-property (point) (1+ (point)) 'auto-save status)
             ))
      (setq overwrite-mode nil)
      (setq buffer-read-only 't)
      )))

(defun desktop-recover-toggle-hash-move-down ()
  "Set marker on the current line, move down one."
  (interactive)
  (desktop-recover-toggle-hash)
  (forward-line 1))

(defun desktop-recover-define-global-key-bindings (&optional prefix)
  "Defines some global keybindings to manually manipulate desktop saves.
These bindings are not required for normal use, but might be convenient
under some circumstances.  The standard bindings here will use the
given PREFIX, which defaults to \"\\C-c%\" (That's control c, followed
by the percent key). The bindings are:
  <prefix> +    desktop-recover-increase-save-period
  <prefix> -    desktop-recover-decrease-save-period
  <prefix> s    desktop-recover-save-with-danglers"
  (interactive)
  (unless prefix (setq prefix "\C-c%"))
  (global-set-key (format "%s+" prefix) 'desktop-recover-increase-save-period)
  (global-set-key (format "%s-" prefix) 'desktop-recover-decrease-save-period)
  (global-set-key (format "%ss" prefix) 'desktop-recover-save-with-danglers)
  (message "Defined bindings for keys: + - s under the prefix %s" prefix)
  )

;; DEBUG
;; (desktop-recover-define-global-key-bindings "\C-c'")

;;=======
;; recover-file *quietly*

;; Sleazy cut-and paste of a routine from files.el, so that
;; I can get rid of the "Recover auto save file?" question.
;; TODO submit a patch with a force option.
(defun desktop-recover-recover-file (file)
  "Visit file FILE, but get contents from its last auto-save file.
This bears an amazing resemblence to recover-file from files.el.
It does almost precisely the same thing, but it shuts up about it."
  ;; Actually putting the file name in the minibuffer should be used
  ;; only rarely.
  ;; Not just because users often use the default.
  (interactive "FRecover file: ")
  (setq file (expand-file-name file))
  (if (auto-save-file-name-p (file-name-nondirectory file))
      (error "%s is an auto-save file" (abbreviate-file-name file)))
  (let ((file-name (let ((buffer-file-name file))
		     (make-auto-save-file-name))))
    (cond ((if (file-exists-p file)
	       (not (file-newer-than-file-p file-name file))
	     (not (file-exists-p file-name)))
	   (error "Auto-save file %s not current"
		  (abbreviate-file-name file-name)))
	  (t ;; desktop-recover always does this without question
           (save-window-excursion
	     (with-output-to-temp-buffer "*Directory*"
	       (buffer-disable-undo standard-output)
	       (save-excursion
		 (let ((switches dired-listing-switches))
		   (if (file-symlink-p file)
		       (setq switches (concat switches "L")))
		   (set-buffer standard-output)
		   ;; Use insert-directory-safely, not insert-directory,
		   ;; because these files might not exist.  In particular,
		   ;; FILE might not exist if the auto-save file was for
		   ;; a buffer that didn't visit a file, such as "*mail*".
		   ;; The code in v20.x called `ls' directly, so we need
		   ;; to emulate what `ls' did in that case.
		   (insert-directory-safely file switches)
		   (insert-directory-safely file-name switches))))
             ;; Commenting out for quieter operation -- doom@kzsu.stanford.edu
	     ;; (yes-or-no-p (format "Recover auto save file %s? " file-name))
             )
	   (switch-to-buffer (find-file-noselect file t))
	   (let ((inhibit-read-only t)
		 ;; Keep the current buffer-file-coding-system.
		 (coding-system buffer-file-coding-system)
		 ;; Auto-saved file should be read with special coding.
		 (coding-system-for-read 'auto-save-coding))
	     (erase-buffer)
	     (insert-file-contents file-name nil)
	     (set-buffer-file-coding-system coding-system))
	   (after-find-file nil nil t))
	  ;; (t (error "Recover-file cancelled"))
          )))

;;; desktop-recover.el ends here

